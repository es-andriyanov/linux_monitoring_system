# Linux Monitoring System

Мониторинг и исследование состояния системы в реальном времени и базовые вспомогательные скрипты.
Проверено на *Ubuntu Server 20.04 LTS*

## Contents

- [Linux Monitoring System](#linux-monitoring-system)
  - [Contents](#contents)
  - [Part 1.](#part-1)
  - [Part 2.](#part-2)
  - [Part 3.](#part-3)
  - [Part 4.](#part-4)
  - [Part 5.](#part-5)
  - [Part 6.](#part-6)
  - [Part 7.](#part-7)
  - [Part 8.](#part-8)
  - [Part 9.](#part-9)
  - [Part 10.](#part-10)
  - [Part 11.](#part-11)
  - [Part 12.](#part-12)
  - [Part 13.](#part-13)
  - [Part 14.](#part-14)

## Part 1.
Bash-скрипт с одним текстовым параметром.  
Скрипт выводит значение параметра.  
Если параметр - число, то выводится сообщение о некорректности ввода.

## Part 2.
Bash-скрипт выводит на экран информацию в виде:

**HOSTNAME** = _сетевое имя_  
**TIMEZONE** = _временная зона в виде: **America/New_York UTC -5** (временная зона, берется из системы)_  
**USER** = _текущий пользователь который запустил скрипт_  
**OS** = _тип и версия операционной системы_  
**DATE** = _текущее время в виде: **12 May 2020 12:24:36**_  
**UPTIME** = _время работы системы_  
**UPTIME_SEC** = _время работы системы в секундах_  
**IP** = _ip-адрес машины в любом из сетевых интерфейсов_  
**MASK** = _сетевая маска любого из сетевых интерфейсов в виде: **xxx.xxx.xxx.xxx**_  
**GATEWAY** = _ip шлюза по умолчанию_  
**RAM_TOTAL** = _размер оперативной памяти в Гб c точностью три знака после запятой в виде: **3.125 GB**_  
**RAM_USED** = _размер используемой памяти в Гб c точностью три знака после запятой_  
**RAM_FREE** = _размер свободной памяти в Гб c точностью три знака после запятой_  
**SPACE_ROOT** = _размер рутового раздела в Mб с точностью два знака после запятой в виде: **254.25 MB**_  
**SPACE_ROOT_USED** = _размер занятого пространства рутового раздела в Mб с точностью два знака после запятой_  
**SPACE_ROOT_FREE** = _размер свободного пространства рутового раздела в Mб с точностью два знака после запятой_

После вывода значений возможно данные в файл (необходимо ответить **Y/N**).  
Ответы **Y** и **y** считаются положительными, все прочие - отрицательными.
При согласии пользователя, в текущей директории создается файл содержащий информацию, которая была выведена на экран.  
Название файла имеет вид: **DD_MM_YY_HH_MM_SS.status**.

## Part 3.
Bash-скрипт на основе [**Part 2**](#part-2) без части, ответственной за сохранение данных в файл.  
Скрипт запускается с 4 параметрами. Параметры числовые. От 1 до 6, например:  
`script03.sh 1 3 4 5`

Обозначения цветов: (1 - white, 2 - red, 3 - green, 4 - blue, 5 – purple, 6 - black)  
**Параметр 1** - это фон названий значений (HOSTNAME, TIMEZONE, USER и т.д.)  
**Параметр 2** - это цвет шрифта названий значений (HOSTNAME, TIMEZONE, USER и т.д.)  
**Параметр 3** - это фон значений (после знака '=')  
**Параметр 4** - это цвет шрифта значений (после знака '=')

Цвета шрифта и фона одного столбца не должны совпадать.  
При вводе совпадающих значений выводится сообщение, описывающее проблему, и предложение повторно вызвать скрипт.  

## Part 4. 
Bash-скрипт на основе [**Part 3**](#part-3). Обозначения цветов аналогичные.  
Скрипт запускается без параметров. Параметры задаются в конфигурационном файле до запуска скрипта.  
Конфигурационный файл имеет вид:
```
column1_background=2
column1_font_color=4
column2_background=5
column2_font_color=1
```

Если один или несколько параметров не заданы в конфигурационном файле, то цвет подставляется из цветовой схемы, заданной по умолчанию.

После вывода информации о системе из [**Part 3**](#part-3) выводится цветовая схема в следующем виде:
```
Column 1 background = 2 (red)
Column 1 font color = 4 (blue)
Column 2 background = 5 (purple)
Column 2 font color = 1 (white)
```

При запуске скрипта с цветовой схемой по умолчанию вывод имеет вид:
```
Column 1 background = default (black)
Column 1 font color = default (white)
Column 2 background = default (red)
Column 2 font color = default (blue)
```

## Part 5.
Bash-скрипт с одним параметром.  
Параметр - это абсолютный или относительный путь до какой-либо директории. Параметр должен заканчиваться знаком '/', например:  
`script05.sh /var/log/`

Скрипт выводит следующую информацию о каталоге, указанном в параметре:
- Общее число папок, включая вложенные
- Топ 5 папок с самым большим весом в порядке убывания (путь и размер)
- Общее число файлов
- Число конфигурационных файлов (с расширением .conf), текстовых файлов, исполняемых файлов, логов (файлов с расширением .log), архивов, символических ссылок
- Топ 10 файлов с самым большим весом в порядке убывания (путь, размер и тип)
- Топ 10 исполняемых файлов с самым большим весом в порядке убывания (путь, размер и хеш)
- Время выполнения скрипта

Информация выводится в виде:

```
Total number of folders (including all nested ones) = 6  
TOP 5 folders of maximum size arranged in descending order (path and size):  
1 - /var/log/one/, 100 GB  
2 - /var/log/two/, 100 MB  
etc up to 5
Total number of files = 30
Number of:  
Configuration files (with the .conf extension) = 1 
Text files = 10  
Executable files = 5
Log files (with the extension .log) = 2  
Archive files = 3  
Symbolic links = 4  
TOP 10 files of maximum size arranged in descending order (path, size and type):  
1 - /var/log/one/one.exe, 10 GB, exe  
2 - /var/log/two/two.log, 10 MB, log  
etc up to 10  
TOP 10 executable files of the maximum size arranged in descending order (path, size and MD5 hash of file)  
1 - /var/log/one/one.exe, 10 GB, 3abb17b66815bc7946cefe727737d295  
2 - /var/log/two/two.exe, 9 MB, 53c8fdfcbb60cf8e1a1ee90601cc8fe2  
etc up to 10  
Script execution time (in seconds) = 1.5
```

## Part 6.
Bash-скрипт с 6 параметрами. Пример запуска скрипта: \
`main.sh /opt/test 4 az 5 az.az 3kb` 

**Параметр 1** - это абсолютный путь. \
**Параметр 2** - количество вложенных папок. \
**Параметр 3** - список букв английского алфавита, используемый в названии папок (не более 7 знаков). \
**Параметр 4** - количество файлов в каждой созданной папке. \
**Параметр 5** - список букв английского алфавита, используемый в имени файла и расширении (не более 7 знаков для имени, не более 3 знаков для расширения). \
**Параметр 6** - размер файлов (в килобайтах, но не более 100).  

Имена папок и файлов состоят только из букв, указанных в параметрах, и используют каждую из них хотя бы 1 раз.  
Длина этой части имени от 4 знаков, плюс дата запуска скрипта в формате DDMMYY, отделённая нижним подчёркиванием, например: \
**./aaaz_021121/**, **./aaazzzz_021121** 

При этом, если для имени папок или файлов были заданы символы `az`, то в названии файлов или папок не будет обратной записи: \
**./zaaa_021121/**, т.е. порядок указанных символов в параметре сохраняется.

При запуске скрипта в указанном в параметре 1 месте создаются папки и файлы в них с соответствующими именами и размером.  
Скрипт останавливает работу, если в файловой системе (в разделе /) останется 1 Гб свободного места.  
После создается лог файл с данными по всем созданным папкам и файлам (полный путь, дата создания, размер для файлов).

## Part 7. 
Bash-скрипт с 3 параметрами. Пример запуска скрипта: \
`main.sh az az.az 3Mb`

**Параметр 1** - список букв английского алфавита, используемый в названии папок (не более 7 знаков). \
**Параметр 2** - список букв английского алфавита, используемый в имени файла и расширении (не более 7 знаков для имени, не более 3 знаков для расширения). \
**Параметр 3** - размер файла (в Мегабайтах, но не более 100).  

Имена папок и файлов состоят только из букв, указанных в параметрах, и используют каждую из них хотя бы 1 раз.  
Длина этой части имени от 5 знаков, плюс дата запуска скрипта в формате DDMMYY, отделённая нижним подчёркиванием, например: \
**./aaaz_021121/**, **./aaazzzz_021121** 

При этом, если для имени папок или файлов были заданы символы `az`, то в названии файлов или папок не будет обратной записи: \
**./zaaa_021121/**, т.е. порядок указанных символов в параметре сохраняется.

При запуске скрипта в различных (любых, кроме путей содержащих **bin** или **sbin**) местах файловой системы создаются папки с файлами.
Количество вложенных папок - до 100. Количество файлов в каждой папке - случайное число (для каждой папки своё).  
Скрипт останавливает работу, когда в файловой системе (в разделе /, по команде `df -h /`) останется 1 Гб свободного места.  

После создается лог файл с данными по всем созданным папкам и файлам (полный путь, дата создания, размер для файлов).  
В конце работы скрипта выводится время начала работы скрипта, время окончания и общее время его работы, которые записываются и в лог-файл.

## Part 8. 
Bash-скрипт с 1 параметром.
Скрипт очищает систему от созданных в [Part 7](#part-7) папок и файлов 3 способами:

1. По лог файлу
2. По дате и времени создания
3. По маске имени (т.е. символы, нижнее подчёркивание и дата).  

Способ очистки задается при запуске скрипта, как параметр со значением 1, 2 или 3.

*При удалении по дате и времени создания, пользователем вводятся времена начала и конца с точностью до минуты. Удаляются все файлы, созданные в указанном временном промежутке.*

## Part 9.
Bash-скрипт, генерирующий 5 файлов логов **nginx** в *combined* формате.
Каждый лог содержит информацию за 1 день.

За день генерируется случайное число записей от 100 до 1000.
Для каждой записи случайным образом генерируются:

1. IP (любые корректные, т.е. не должно быть ip вида 999.111.777.777)
2. Коды ответа (200, 201, 400, 401, 403, 404, 500, 501, 502, 503)
3. Методы (GET, POST, PUT, PATCH, DELETE)
4. Даты (в рамках заданного дня лога, должны идти по увеличению)
5. URL запроса агента
6. Агенты (Mozilla, Google Chrome, Opera, Safari, Internet Explorer, Microsoft Edge, Crawler and bot, Library and net tool)

## Part 10. 
Bash-скрипт для разбора логов **nginx** из [Part 9](#part-9) через **awk**.

Скрипт запускается с 1 параметром, который принимает значение 1, 2, 3 или 4.
В зависимости от значения параметра выводятся:

1. Все записи, отсортированные по коду ответа
2. Все уникальные IP, встречающиеся в записях
3. Все запросы с ошибками (код ответа - 4хх или 5хх)
4. Все уникальные IP, которые встречаются среди ошибочных запросов

## Part 11. 
С помощью утилиты GoAccess получаем ту же информацию, что и в [Part 10](#part-10)

Открывыем веб интерфейс утилиты на локальной машине.

## Part 12.
Устанавливаем и настраиваем **Prometheus** и **Grafana** на виртуальную машину

Получаем доступ к веб интерфейсам **Prometheus** и **Grafana** с локальной машины

Добавляем на дашборд **Grafana** отображение ЦПУ, доступной оперативной памяти, свободное место и кол-во операций ввода/вывода на жестком диске

Запускаем bash-скрипт из [Part 7](#part-7)

Смотрим на нагрузку жесткого диска (место на диске и операции чтения/записи)

Устанавливаем утилиту **stress** и запускаем команду `stress -c 2 -i 1 -m 1 --vm-bytes 32M -t 10s`

Смотрим на нагрузку жесткого диска, оперативной памяти и ЦПУ

## Part 13. 
Устанавливаем готовый дашборд *Node Exporter Quickstart and Dashboard* с официального сайта **Grafana Labs**

Проводим те же тесты, что и в [Part 12](#part-12)

Запускаем ещё одну виртуальную машину, находящуюся в одной сети с текущей

Запускаем тест нагрузки сети с помощью утилиты **iperf3**

Смотрим на нагрузку сетевого интерфейса

## Part 14. 
Bash-скрипт, собирающий информацию по базовым метрикам системы (ЦПУ, оперативная память, жесткий диск (объем)).
Скрипт формирует html страничку по формату **Prometheus**, которую будет отдавать **nginx**. \
Саму страничку обновляем внутри bash-скрипт (либо при помощи утилиты cron) не чаще, чем раз в 3 секунды.

Меняем конфигурационный файл **Prometheus**, чтобы он собирал информацию с созданной нами странички.

Проводим те же тесты, что и в [Part 12](#part-12)